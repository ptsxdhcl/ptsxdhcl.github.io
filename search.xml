<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>排序问题</title>
      <link href="/2018/12/12/pai-xu-wen-ti/"/>
      <url>/2018/12/12/pai-xu-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1,快速排序"></a>1,快速排序</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">QuitSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>    arrayLen <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 数组的长度</span>    <span class="token keyword">if</span> arrayLen <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">#长度为1 的话 或者 空 的话 直接返回 数组</span>        <span class="token keyword">return</span> array    <span class="token keyword">if</span> right <span class="token operator">==</span> None<span class="token punctuation">:</span>        right <span class="token operator">=</span> arrayLen <span class="token operator">-</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># 索引</span>    <span class="token keyword">if</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>        poivt <span class="token operator">=</span> Partition<span class="token punctuation">(</span>array<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>        QuitSort<span class="token punctuation">(</span>array<span class="token punctuation">,</span>left<span class="token punctuation">,</span>poivt<span class="token number">-1</span><span class="token punctuation">)</span>        QuitSort<span class="token punctuation">(</span>array<span class="token punctuation">,</span>poivt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">Partition</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>    i <span class="token operator">=</span> left <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>            i <span class="token operator">+=</span> <span class="token number">1</span>            array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    array<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>array<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span>array<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">35</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token number">44</span><span class="token punctuation">]</span>    QuitSort<span class="token punctuation">(</span>array<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序结束："</span><span class="token punctuation">,</span>array<span class="token punctuation">)</span></code></pre><h2 id="2，归并排序"><a href="#2，归并排序" class="headerlink" title="2，归并排序"></a>2，归并排序</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>    arrayLen <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span>    <span class="token keyword">if</span> arrayLen <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> array    middleNum <span class="token operator">=</span> arrayLen <span class="token operator">//</span> <span class="token number">2</span>    leftArray <span class="token operator">=</span> MergeSort<span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token punctuation">:</span>middleNum<span class="token punctuation">]</span><span class="token punctuation">)</span>    rightArray <span class="token operator">=</span> MergeSort<span class="token punctuation">(</span>array<span class="token punctuation">[</span>middleNum<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    retArray <span class="token operator">=</span> MergeCore<span class="token punctuation">(</span>leftArray<span class="token punctuation">,</span>rightArray<span class="token punctuation">)</span>    <span class="token keyword">return</span> retArray<span class="token keyword">def</span> <span class="token function">MergeCore</span><span class="token punctuation">(</span>leftArray<span class="token punctuation">,</span>rightArray<span class="token punctuation">)</span><span class="token punctuation">:</span>    leftPointer <span class="token operator">=</span> <span class="token number">0</span>    rightPointer <span class="token operator">=</span> <span class="token number">0</span>    leftLen <span class="token operator">=</span> len<span class="token punctuation">(</span>leftArray<span class="token punctuation">)</span>    rightLen <span class="token operator">=</span> len<span class="token punctuation">(</span>rightArray<span class="token punctuation">)</span>    retList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">while</span> leftPointer <span class="token operator">&lt;</span> leftLen <span class="token operator">and</span> rightPointer <span class="token operator">&lt;</span> rightLen<span class="token punctuation">:</span>        <span class="token keyword">if</span> leftArray<span class="token punctuation">[</span>leftPointer<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rightArray<span class="token punctuation">[</span>rightPointer<span class="token punctuation">]</span><span class="token punctuation">:</span>            retList<span class="token punctuation">.</span>append<span class="token punctuation">(</span>leftArray<span class="token punctuation">[</span>leftPointer<span class="token punctuation">]</span><span class="token punctuation">)</span>            leftPointer <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            retList<span class="token punctuation">.</span>append<span class="token punctuation">(</span>rightArray<span class="token punctuation">[</span>rightPointer<span class="token punctuation">]</span><span class="token punctuation">)</span>            rightPointer <span class="token operator">+=</span><span class="token number">1</span>    retList<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>leftArray<span class="token punctuation">[</span>leftPointer<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    retList <span class="token operator">+=</span> rightArray<span class="token punctuation">[</span>rightPointer<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> retList<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">35</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token number">44</span><span class="token punctuation">]</span>    retList <span class="token operator">=</span> MergeSort<span class="token punctuation">(</span>array<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序结束："</span><span class="token punctuation">,</span>retList<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 排序 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>爬虫面试题</title>
      <link href="/2018/12/10/pa-chong-mian-shi-ti/"/>
      <url>/2018/12/10/pa-chong-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="1，简述一下爬虫的步骤。"><a href="#1，简述一下爬虫的步骤。" class="headerlink" title="1，简述一下爬虫的步骤。"></a>1，简述一下爬虫的步骤。</h2><pre class=" language-markdown"><code class="language-markdown">1、确定需求；2、确定资源；3、通过url获取网站的返回数据；4、定位数据；5、存储数据。</code></pre><h2 id="2，遇到反爬机制怎么处理？"><a href="#2，遇到反爬机制怎么处理？" class="headerlink" title="2，遇到反爬机制怎么处理？"></a>2，遇到反爬机制怎么处理？</h2><pre class=" language-markdown"><code class="language-markdown">反爬机制:headers方向判断User-Agent、判断Referer、判断Cookie。将浏览器的headers信息全部添加进去注意：Accept-Encoding；gzip,deflate需要注释掉</code></pre><h2 id="3，常见的HTTP方法有哪些？"><a href="#3，常见的HTTP方法有哪些？" class="headerlink" title="3，常见的HTTP方法有哪些？"></a>3，常见的HTTP方法有哪些？</h2><pre class=" language-markdown"><code class="language-markdown">GET：请求指定的页面信息，返回实体主体；HEAD:类似于get请求，只不过返回的响应中没有具体的内容，用于捕获报头；POST：向指定资源提交数据进行处理请求(比如表单提交或者上传文件)，。数据被包含在请求体中。PUT:从客户端向服务端传送数据取代指定的文档的内容；DELETE：请求删除指定的页面；CONNNECT：HTTP1.1协议中预留给能够将连接方式改为管道方式的代理服务器；OPTIONS:允许客户端查看服务器的性能；TRACE：回显服务器的请求，主要用于测试或者诊断。</code></pre><h2 id="4，说一说redis-scrapy中redis的作用。"><a href="#4，说一说redis-scrapy中redis的作用。" class="headerlink" title="4，说一说redis-scrapy中redis的作用。"></a>4，说一说redis-scrapy中<code>redis</code>的作用。</h2><pre class=" language-markdown"><code class="language-markdown">它是将scrapy框架中Scheduler替换为redis数据库，实现队列管理共享。优点：  1、可以充分利用多台机器的带宽；  2、可以充分利用多台机器的IP地址。</code></pre><h2 id="5，遇到的反爬虫策略以及解决方法。"><a href="#5，遇到的反爬虫策略以及解决方法。" class="headerlink" title="5，遇到的反爬虫策略以及解决方法。"></a>5，遇到的反爬虫策略以及解决方法。</h2><pre class=" language-markdown"><code class="language-markdown">1、通过headers反爬虫：自定义headers，添加网页中的headers数据。2、基于用户行为的反爬虫(封IP)：可以使用多个代理IP爬取或者将爬取的频率降低。3、动态网页反爬虫(JS或者Ajax请求数据)：动态网页可以使用 selenium + phantomjs 抓取。4、对部分数据加密处理(数据乱码):找到加密方法进行逆向推理。</code></pre><h2 id="6，如果让你来防范网站爬虫，你应该怎么来提高爬取的难度-？"><a href="#6，如果让你来防范网站爬虫，你应该怎么来提高爬取的难度-？" class="headerlink" title="6，如果让你来防范网站爬虫，你应该怎么来提高爬取的难度 ？"></a>6，如果让你来防范网站爬虫，你应该怎么来提高爬取的难度 ？</h2><pre class=" language-markdown"><code class="language-markdown">1、判断headers的User-Agent；2、检测同一个IP的访问频率；3、数据通过Ajax获取；4、爬取行为是对页面的源文件爬取，如果要爬取静态网页的html代码，可以使用jquery去模仿写html。</code></pre><h2 id="7，urllib和urllib2的区别？"><a href="#7，urllib和urllib2的区别？" class="headerlink" title="7，urllib和urllib2的区别？"></a>7，<code>urllib</code>和<code>urllib2</code>的区别？</h2><pre class=" language-markdown"><code class="language-markdown">这两个都是接收url请求的模块。两者常常配合一块使用，但是功能不一样。1、urllib2可以接收一个Request类的实例来设置url请求的headers；而urllib只能接收url，因此不能伪装User-Agent字符串。2、urllib提供了urlencode方法用来get查询字符串的产生，而urllib2没有。</code></pre><h2 id="8，scrapy分为几个组成部分？分别有什么作用？"><a href="#8，scrapy分为几个组成部分？分别有什么作用？" class="headerlink" title="8，scrapy分为几个组成部分？分别有什么作用？"></a>8，scrapy分为几个组成部分？分别有什么作用？</h2><pre class=" language-markdown"><code class="language-markdown">分为5个部分；Spiders(爬虫类)，Scrapy Engine(引擎),Scheduler(调度器),Downloader(下载器),Item Pipeline(处理管道)。Spiders:开发者自定义的一个类，用来解析网页并抓取指定url返回的内容。Scrapy Engine:控制整个系统的数据处理流程，并进行事务处理的触发。Scheduler：接收Engine发出的requests，并将这些requests放入到处理列队中，以便之后engine需要时再提供。Download：抓取网页信息提供给engine，进而转发至Spiders。Item Pipeline:负责处理Spiders类提取之后的数据。比如清理HTML数据、验证爬取的数据(检查item包含某些字段)、查重(并丢弃)、将爬取结果保存到数据库中</code></pre><h2 id="9，简述一下scrapy的基本流程。"><a href="#9，简述一下scrapy的基本流程。" class="headerlink" title="9，简述一下scrapy的基本流程。"></a>9，简述一下scrapy的基本流程。</h2><p><img src="https://image-static.segmentfault.com/281/666/2816666215-5a25a21f9f37d_articlex" alt="请看大图"></p><pre><code>scrapy分为9个步骤。1、Spiders需要初始的start_url或则函数stsrt_requests,会在内部生成Requests给Engine；2、Engine将requests发送给Scheduler;3、Engine从Scheduler那获取requests,交给Download下载；4、在交给Dowmload过程中会经过Downloader Middlewares(经过process_request函数)；5、Dowmloader下载页面后生成一个response，这个response会传给Engine，这个过程中又经过了Downloader Middlerwares(经过process_request函数)，在传送中出错的话经过process_exception函数；6、Engine将从Downloader那传送过来的response发送给Spiders处理，这个过程经过Spiders Middlerwares(经过process_spider_input函数)；7、Spiders处理这个response，返回Requests或者Item两个类型，传给Engine，这个过程又经过Spiders Middlewares(经过porcess_spider_output函数)；8、Engine接收返回的信息，如果使Item，将它传给Items Pipeline中；如果是Requests,将它传给Scheduler，继续爬虫；9、重复第三步，直至没有任何需要爬取的数据</code></pre><h2 id="10，常见的页面数据抽取方式有哪些？"><a href="#10，常见的页面数据抽取方式有哪些？" class="headerlink" title="10，常见的页面数据抽取方式有哪些？"></a>10，常见的页面数据抽取方式有哪些？</h2><pre class=" language-python"><code class="language-python">xpathrebeautfulsoup4jsonpathcssselector</code></pre><h2 id="11，是否搭建过爬虫集群，集群是如何实现节点发现和管理的？"><a href="#11，是否搭建过爬虫集群，集群是如何实现节点发现和管理的？" class="headerlink" title="11，是否搭建过爬虫集群，集群是如何实现节点发现和管理的？"></a>11，是否搭建过爬虫集群，集群是如何实现节点发现和管理的？</h2><pre class=" language-markdown"><code class="language-markdown"></code></pre><h2 id="12，遇到过哪些反爬的案例，分别是如何解决的（不限一种）。"><a href="#12，遇到过哪些反爬的案例，分别是如何解决的（不限一种）。" class="headerlink" title="12，遇到过哪些反爬的案例，分别是如何解决的（不限一种）。"></a>12，遇到过哪些反爬的案例，分别是如何解决的（不限一种）。</h2><pre class=" language-markdown"><code class="language-markdown"></code></pre>]]></content>
      
      
      <categories>
          
          <category> python爬虫 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库面试题</title>
      <link href="/2018/11/30/shu-ju-ku-mian-shi-ti/"/>
      <url>/2018/11/30/shu-ju-ku-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="1，order-by-和-group-by-的区别？"><a href="#1，order-by-和-group-by-的区别？" class="headerlink" title="1，order by 和 group by 的区别？"></a>1，<code>order by</code> 和 <code>group by</code> 的区别？</h2><pre class=" language-markdown"><code class="language-markdown">两者都是sql语句中的查询关键字。order by 用于对结果集按照一个列或者多个列进行排序。其中ASC是升序，DESC是降序排序。group by 用于集合聚合函数，根据一个列或者多个列对结果集进行分组。后面可以使用having条件。</code></pre><h2 id="2，简述关系型数据库和非关系型数据库的区别？并举例。"><a href="#2，简述关系型数据库和非关系型数据库的区别？并举例。" class="headerlink" title="2，简述关系型数据库和非关系型数据库的区别？并举例。"></a>2，简述关系型数据库和非关系型数据库的区别？并举例。</h2><p><a href="https://www.jianshu.com/p/fd7b422d5f93" target="_blank" rel="noopener">点击查看</a></p><pre class=" language-markdown"><code class="language-markdown">关系型数据库由二维表及外键组成的一个数据组织。比如MySQL，oracle。它的优点在于使用方便、易于维护、容易理解。它有以下几个特点：1、高度组织化结构化数据；2、结构化查询语句(SQL)；3、数据和关系都存储在单独的表中；4、可以使用join关联查询。非关系型数据库通常是指数据以键值对(key-value)的形式存储,基于分布式的结构不稳定的数据库。比如Redis，MongoDB。它的优点在于用户查询时不需要多表关联查询，查询速度快。它有以下几个特点：1、非结构化存储；2、没有声明性查询语句；3；支持高并发；4、基于支持分布式，易于拓展，可伸缩。</code></pre><h2 id="3，什么是事务？它的特性是什么？"><a href="#3，什么是事务？它的特性是什么？" class="headerlink" title="3，什么是事务？它的特性是什么？"></a>3，什么是事务？它的特性是什么？</h2><pre class=" language-markdown"><code class="language-markdown">事务是一系列数据库操作，是数据库应用的基本逻辑。它的特性是：原子性(A)、一致性(C)、隔离性(I)、持久性(D)。原子性：事务要么执行全部被成功，要么全部不被执行；一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态；隔离性：多个事务互不影响；持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。</code></pre><h2 id="4，MySQL的常用类型有哪些？"><a href="#4，MySQL的常用类型有哪些？" class="headerlink" title="4，MySQL的常用类型有哪些？"></a>4，<code>MySQL</code>的常用类型有哪些？</h2><pre class=" language-markdown"><code class="language-markdown">常用类型有：字符串类型，数值类型，日期和时间类型。字符串类型包括:char,varchar,text。char是定长字符串，长度范围在0-255字节；varchar是变长字符串，长度范围在0-65535字节；text是长文本数据，长度范围在0-65535字节。varchar类型可以根据实际内容动态改变存储值的长度，与char相比可以节约磁盘空间，提高存储效率；与text相比可以设置默认值。数值类型包括:tinyint,int,bigint,decimal。tinyint是极小整数型，以1个字节存储；int是整数型，以4个字节存储；bigint是极大整数型，以8个字节存储；decimal是定点数，是高精度的数据类型，decimal(m,n)中m代表精度，n代表小数点右侧的位数。时间类型包括：date,time,datetime。date精确到年月日，占3个字节；(YYYY-MM-DD  2018-12-03)time精确到时分秒，占3个字节；(HH:MM:AA  14:33:20)datetime精确的年月日时分秒，占8个字节。(YYYY-MM-DD HH:MM:AA 2018-12-03 14:33:20)</code></pre><h2 id="5，如何对查询语句进行优化？"><a href="#5，如何对查询语句进行优化？" class="headerlink" title="5，如何对查询语句进行优化？"></a>5，如何对查询语句进行优化？</h2><p><a href="https://blog.csdn.net/u012506661/article/details/80425146" target="_blank" rel="noopener">点击查看详情</a></p><pre class=" language-markdown"><code class="language-markdown">开启慢查询日志--->找到执行较慢的sql语句--->使用explain或desc具体分析sql语句。优化方案：通过使用或建立索引提高sql的执行效率。1、给经常作为查询条件的字段添加索引；2、添加索引的字段尽量保持唯一性；3、在使用索引时，注意索引类型；4、在使用like模糊查询时，%和_ 不要出现在前面。</code></pre><h2 id="6，NoSQL了解么，和关系数据库的区别？"><a href="#6，NoSQL了解么，和关系数据库的区别？" class="headerlink" title="6，NoSQL了解么，和关系数据库的区别？"></a>6，<code>NoSQL</code>了解么，和关系数据库的区别？</h2><p><a href="https://www.jianshu.com/p/2d2a951fe0df" target="_blank" rel="noopener">点击查看详情</a></p><pre class=" language-markdown"><code class="language-markdown">NoSQL(Not only SQL)是非关系型数据库。是以键值对的形式用于超大规模数据的存储。它的特点如下：1、非结构化存储；2、没有声明性查询语句；3；支持高并发；4、基于支持分布式，易于拓展，可伸缩。关系型数据库通过外键关联来建立表与表之间的关系。它的特点如下：1、高度组织化结构化数据；2、结构化查询语句(SQL)；3、数据和关系都存储在单独的表中；4、可以使用join关联查询。</code></pre><h2 id="7，redis有几种常用的存储类型？"><a href="#7，redis有几种常用的存储类型？" class="headerlink" title="7，redis有几种常用的存储类型？"></a>7，<code>redis</code>有几种常用的存储类型？</h2><pre class=" language-markdown"><code class="language-markdown">redis是基于内存，可选持久性的以键值对存储的非关系型数据库。存储类型如下：字符串(string)、哈希(hash)、列表(list)、集合(set)、有序集合(sorted set)。</code></pre><h2 id="8，索引是什么？有什么作用及优缺点？"><a href="#8，索引是什么？有什么作用及优缺点？" class="headerlink" title="8，索引是什么？有什么作用及优缺点？"></a>8，索引是什么？有什么作用及优缺点？</h2><pre class=" language-markdown"><code class="language-markdown">索引是对数据库表中一个或多个列的值进行排序的结构，它可以帮助mysql高效获取数据。索引的实现通常使用B树和B+树。索引又可以分为普通索引，唯一索引，主键索引，全文索引。普通索引：最基本的索引类型；唯一索引：与普通索引不同的是索引列的所有值都必须是唯一；主键索引：一种特殊的唯一索引，不允许有空值；全文索引：用于在一片文章中检索文本信息。索引的优点：1、创建唯一索引保证数据库表中每一行数据的唯一性；2、加快数据的检索速度；3、通过索引可以在查询的过程中使用优化隐藏器，提高系统的性能。缺点：1、创建和维护索引需要耗费时间；2、索引需要占据物理空间；3、当对表进行增加，修改和删除时，索引也需要动态维护，这样会降低数据的维护速度。</code></pre><h2 id="9，MySQL数据库的有几种引擎？和使用场景。"><a href="#9，MySQL数据库的有几种引擎？和使用场景。" class="headerlink" title="9，MySQL数据库的有几种引擎？和使用场景。"></a>9，<code>MySQL数据库</code>的有几种引擎？和使用场景。</h2><p><a href="http://uule.iteye.com/blog/2420424" target="_blank" rel="noopener">点击查看详情</a></p><pre class=" language-markdown"><code class="language-markdown">主要有Innodb和MyISAM。Innodb是一个事务型的存储引擎(MySQL的默认引擎)，它的设计目标是处理大量数据时提供高性能的服务，它在运行时会在内存中建立缓冲池，用于缓冲数据和索引。它具有以下几个优点：1、支持事务，遵守ACID原则；2、实现sql标准的四种隔离级别；3、支持外键和行级锁；4、可以利用事务日志进行数据恢复。但是它不支持fulltext类型的索引，因此当使用count统计时会扫描全表。使用场景：1、需要事务的操作；2、更新数据需要用到行级锁；3、大数据读写；4、大型互联网应用。MyISAM是MySQL 5.1之前的默认引擎，它的设计目标是快速读取。优点如下：1、高性能读取；2、支持fulltext类型的全文索引，索引count统计时不会扫描全表。缺点:1、不支持数据库事务；2、只支持表级锁，不支持行级锁和外键；3、不支持故障恢复。使用场景：1、不需要事务操作；2、插入，更新少，读取频繁；3、频繁的使用count统计。</code></pre><h2 id="10，简单比较一下RDBMS和NoSQL-不超过三句话-。"><a href="#10，简单比较一下RDBMS和NoSQL-不超过三句话-。" class="headerlink" title="10，简单比较一下RDBMS和NoSQL(不超过三句话)。"></a>10，简单比较一下<code>RDBMS</code>和<code>NoSQL</code>(不超过三句话)。</h2><pre class=" language-markdown"><code class="language-markdown">RDBMS是关系型数据库管理系统，NoSQL是非关系数据库。RDBMS分布式困难，NoSQL则比较容易。</code></pre><h2 id="11，简单说一说drop、delete与truncate的区别。"><a href="#11，简单说一说drop、delete与truncate的区别。" class="headerlink" title="11，简单说一说drop、delete与truncate的区别。"></a>11，简单说一说<code>drop</code>、<code>delete</code>与<code>truncate</code>的区别。</h2><pre class=" language-markdown"><code class="language-markdown">这三者都是表达删除的意思。区别如下：1、drop是删除表；delete删除的是表中数据，常与where配合使用；truncate是重置表，它会删除数据，将表中的自增值重置。2、在速度上来说：drop>truncate>delete。使用场景：不再需要一张表时用drop删除；当要删除部分数据时用delete配合where字句；想要保留表而将所有数据删除并且和事务无关的话用truncate，和事务有关时用delete。</code></pre><h2 id="12，redis持久化。"><a href="#12，redis持久化。" class="headerlink" title="12，redis持久化。"></a>12，redis持久化。</h2><p><a href="https://blog.csdn.net/m0_38110132/article/details/76906422" target="_blank" rel="noopener">查看详情</a></p><pre class=" language-markdown"><code class="language-markdown">redis数据都是保存在内存中的，如果没有设置持久化那么重启redis后数据会丢失。于是需要开启redis持久化功能，将数据保存在磁盘中，这样重启后可以从磁盘中恢复数据。两中持久化方法：RDB持久化：将Redis在内存中的数据定时dump到磁盘上；AOF持久化：将Redis的操作日志以追加的方式写入文件。区别：RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端面试题</title>
      <link href="/2018/11/29/qian-duan-mian-shi-ti/"/>
      <url>/2018/11/29/qian-duan-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="1，请描述一下-cookie，sessionStorage和localstorage区别"><a href="#1，请描述一下-cookie，sessionStorage和localstorage区别" class="headerlink" title="1，请描述一下 cookie，sessionStorage和localstorage区别?"></a>1，请描述一下 <code>cookie</code>，<code>sessionStorage</code>和<code>localstorage</code>区别?</h2><p><a href="https://geekjc.com/post/58e10a3867d6027b0d916752" target="_blank" rel="noopener">点击查看详细信息</a></p><pre class=" language-markdown"><code class="language-markdown">cookie是存储于访问者计算机中的变量。每当同一台计算机通过浏览器访问某个页面时都会发送cookie。sessionstorage和localstorage都是HTML5提供的在客户端存储数据的方法。sessionstorage是会话存储，localstorage是本地存储。这三者都是保存在客户端且同源的。它们有以下几个区别：1、数据与服务器间交互方式不同：cookie是在浏览器和服务器间来回传递，而且还有路径(path)的概念，可以限制在cookie只属于某个路径下；而sessionstorage和localstorage不会自动把数据发给服务器，仅在本地保存。2、存储大小限制不同：cookie数据不能超过4k,而sessionstorage和localstorage可以达到5M或更大。3、数据有效期不同：cookie只在设置的cookie过期时间之前有效，即使窗口或浏览器关闭；sessionstorage仅在浏览器窗口关闭之前有效；localstorage持久有效，即使浏览器窗口关闭也可以持久保存。4、作用域不同：sessionstorage在不同的浏览器窗口是不共享的，即使是同一个页面；而localstorage和cookie是在所有的同源窗口共享。</code></pre><h2 id="2-jquery中-get-提交-和-post-提交有区别吗"><a href="#2-jquery中-get-提交-和-post-提交有区别吗" class="headerlink" title="2,jquery中$.get()提交 和$.post()提交有区别吗?"></a>2,jquery中<code>$.get()提交</code> 和<code>$.post()提交</code>有区别吗?</h2><pre class=" language-markdown"><code class="language-markdown">两者都是通过异步请求的方式来获取服务器的数据。区别如下：1、请求方式不同：$.get()方法是通过GET方法进行异步请求的；$.post()是通过POST方法进行异步请求的。2、参数传递方式不同：get请求会将参数跟在url后面进行传递；post请求则是作为http消息的实体内容传递给web服务器，这种传递是用户是不可见的(比如表单提交)。3、数据传输大小不同：get请求的传输数据大小不超过2k，而post要大得多。4、安全问题：get请求的数据会被浏览器缓存起来所有相比post请求来说不安全。</code></pre><h2 id="3-CSRF是什么，可以做什么-CSRF攻击攻击原理及过程-针对CSRF漏洞防御-django是如何避免的"><a href="#3-CSRF是什么，可以做什么-CSRF攻击攻击原理及过程-针对CSRF漏洞防御-django是如何避免的" class="headerlink" title="3,CSRF是什么，可以做什么,CSRF攻击攻击原理及过程,针对CSRF漏洞防御,django是如何避免的?"></a>3,<code>CSRF</code>是什么，可以做什么,CSRF攻击攻击原理及过程,针对CSRF漏洞防御,django是如何避免的?</h2><p><a href="https://www.cnblogs.com/dachenzi/p/8613337.html" target="_blank" rel="noopener">点击查看详情</a></p><pre class=" language-markdown"><code class="language-markdown">一、CSRF是跨站请求伪造，是对网站的恶意利用。二、可以做什么：攻击者盗用你的身份，以你的身份发送恶意请求，但对服务器来说这个请求是合法的。比如以你的名义发邮件、购买商品等。三、CSRF攻击攻击原理及过程：假设 网站A为存在CSFRF漏洞的网站，网站B为攻击者构建的恶意网站，用户C为网站A的合法用户。那么分为五步攻击：1.用户C打开浏览器，访问网站A，输入用户名和密码登录A；2.用户信息验证成功，网站A产生cookie信息返回给浏览器，此时用户登陆成功，可以正常发送请求给网站A;3.用户在未有退出网站A之前，在同一个浏览器中打开一个TAB页面访问网站B；4.网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求访问网站A;5.浏览器在接收到这些攻击性代码后，根据网站B的请求在用户不知情的情况携带cookie信息向网站A发出请求。网站A并不知道该请求是由网站B发起的，所以会根据用户C的cookie信息以C的名义处理请求，导致网站B的代码被执行。四、防御CSRF攻击：1.验证HTTP Referer字段；2.在请求地址中添加token并验证；3.在HTTP头中自定义属性并验证。五、Django是如何避免的：Django中有两种方式传递和验证CSRF token。1.在form表单中添加{% csrf<span class="token italic"><span class="token punctuation">_</span>token %} 来渲染服务端返回的csrf<span class="token punctuation">_</span></span>token；2.在ajax提交中为headers来定制请求头，这时请求头的k键(key)必须为X-CSRFtoken。</code></pre><h2 id="4-XSS是什么？"><a href="#4-XSS是什么？" class="headerlink" title="4,XSS是什么？"></a>4,<code>XSS</code>是什么？</h2><p><a href="https://tech.meituan.com/fe_security.html" target="_blank" rel="noopener">点击查看详情</a></p><pre class=" language-markdown"><code class="language-markdown">XSS是跨站脚本攻击，也叫做代码注入攻击。它的本质是恶意代码未经过过滤，与正常代码混在一起被浏览器一起执行。它又分为存储型XSS,反射型XSS和DOM(文档对象模型)型XSS。1、存储型XSS是恶意代码存储在数据库中然后插入到html里，当浏览器打开网站时会自动解析恶意代码，完成攻击者的指定操作。属于服务端的安全漏洞。比如论坛发帖，商品评论等。2、反射性XSS是将恶意代码保存在URL然后插入到HTML里，当用户点击时才执行恶意代码。属于服务端的安全漏洞。比如网站搜索，跳转。3、DOM型XSS取出和执行恶意代码是由浏览器端完成的，属于前端js自身的安全漏洞。如何防范XSS:1.过滤用户输入的html标签内容；2.对用户的html标签进行转义；Django中默认对所有输出的html标签内容进行转义。</code></pre><h2 id="5，什么是AJAX？GET和POST的请求方式的区别？"><a href="#5，什么是AJAX？GET和POST的请求方式的区别？" class="headerlink" title="5，什么是AJAX？GET和POST的请求方式的区别？"></a>5，什么是<code>AJAX</code>？<code>GET</code>和<code>POST</code>的请求方式的区别？</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX" target="_blank" rel="noopener">参考一</a><br><a href="http://www.cnblogs.com/SanMaoSpace/archive/2013/06/15/3137180.html" target="_blank" rel="noopener">参考二</a></p><pre class=" language-markdown"><code class="language-markdown">AJAX = 异步JavaScrip和XML,意思是用JavaScript执行异步网络请求。它通过后台与服务器进行少量的数据交换，可以使网页实现异步更新。是一种创建快速动态网页的技术。传统的网页如果需要更新内容必须重新加载整个网页，然而通过ajax我们可以不重新加载页面也可以对页面进行部分更新：比如新浪微博、Googel地图等。ajax的工作原理相当于在用户和服务器之间加一个中间层(ajax引擎)，使用户操作与服务器响应异步化。优缺点如下：优点：1、减轻服务器的负担，按需求获取数据，最大程度的减少冗(rong)余请求；2、局部刷新页面，减少等待时间，带来更好的用户体验；3、基于xml标准化，被广泛支持，不需要安装查件，进一步促进页面和数据的分离。缺点：1、对某些浏览器不支持；2、ajax是局部刷新，所以页面的回退按钮无法使用；3、不支持移动设备；4、增加客户端代码量。GET请求比POST请求简单快捷，大部分情况都能使用。但是下面情况请选择POST请求：1、无法缓存文件(更新服务器的文件或数据库)2、向服务器发送大量的数据(POST没有数据量限制)3、发送包含未知字符的用户输入。</code></pre><h2 id="6，简述html，css，js。"><a href="#6，简述html，css，js。" class="headerlink" title="6，简述html，css，js。"></a>6，简述<code>html</code>，<code>css</code>，<code>js</code>。</h2><pre class=" language-markdown"><code class="language-markdown">一个网页设计思路通常是把网页分成三个层次，即：结构层(html),表示层(css),行为层(js)。html是超文本语言，负责创建网页的基本内容和结构；css是层叠样式表，用于设计网页-放置所有内容及外观；js是一种基于对象和时间驱动并具有安全性能的脚本语言。用来负责页面的动态效果。</code></pre><h2 id="7，怎么去设计一个组件封装？"><a href="#7，怎么去设计一个组件封装？" class="headerlink" title="7，怎么去设计一个组件封装？"></a>7，怎么去设计一个组件封装？</h2><pre class=" language-markdown"><code class="language-markdown">组件封装的目的是为了重用，提高开发效率和代码质量。设计原则如下：1、适用单一职责原则；2、低耦合性；3、适用SPOT法则 (Single Point Of Truth，就是尽量不要重复代码，出自《The Art of Unix Programming》)4、可复用性，可维护性。</code></pre><h2 id="8，css动画和js动画的差异："><a href="#8，css动画和js动画的差异：" class="headerlink" title="8，css动画和js动画的差异："></a>8，css动画和js动画的差异：</h2><pre class=" language-markdown"><code class="language-markdown">1、代码复杂度不同：js动画代码相对复杂；2、动画性能：js动画多了一个js解析的过程，性能不如css动画好;3、动画运行时js能够让动画暂停，取消，终止，css动画不能添加事件。</code></pre><h2 id="9，负载均衡："><a href="#9，负载均衡：" class="headerlink" title="9，负载均衡："></a>9，负载均衡：</h2><p><a href="https://www.cnblogs.com/itfly8/p/5043435.html" target="_blank" rel="noopener">点击查看</a></p><pre class=" language-markdown"><code class="language-markdown">当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向拓展，使用集群和负载均衡提高整个系统的处理能力。一般有基于DNS和基于IP报文两种情况。1、利用DNS(域名系统)实现负载均衡就是在DNS服务器配置多个A记录，不同的DNS请求会解析到不同的IP地址。大型网站一般使用DNS作为第一级负载均衡。缺点是DNS生效事件长，拓展性差。2，基于IP报文(网络层传输的数据单元，也叫IP数据报)的负载均衡，具有代表性的是LVS(Linux服务器集群系统)。LVS的原理是在Linux内核态获取IP报文后，根据特定的负载均衡算法将IP报文转发到整个集群的某台服务器中。缺点在于LVS的性能依赖Linux内核的网络性能，但Linux内核的网络路径过长导致大量开销，是的LVS单机性能低。</code></pre><h2 id="10，阐述清除浮动的几种方式？"><a href="#10，阐述清除浮动的几种方式？" class="headerlink" title="10，阐述清除浮动的几种方式？"></a>10，阐述清除浮动的几种方式？</h2><pre class=" language-markdown"><code class="language-markdown">首先浮动元素脱离文档流，不占据空间。然后是浮动元素碰到包含它的边框或者其他浮动元素边框时会停留。所以会导致‘高度塌陷’现象。有4种方法清除浮动。1、父级div定义height：  原理：父级div手动设置height，解决父级div无法自动获取高度的问题。  优点：简单，代码少容易掌握。  缺点：只适合高度固定的布局。2、结尾处加空div标签：clear:both  原理：添加标签让父级div自动获取高度。  优点：简单，代码少，浏览器支持好。  缺点：会额外增加很多空出来的div。3、父级定义伪元素；clearfix  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>推荐使用</span><span class="token punctuation">></span></span>  原理：在父级元素最后，添加了一个:after伪元素，通过清除伪元素的浮动，来撑起父元素高度。4、利用overflow清除浮动：overflow:hidden或overflow:auto  原理：使用overflow；auto时，先定义width，同时不能定义height,这时浏览器会自动检查浮动区域的高度。  优点：简单，代码少，浏览器支持好。  缺点：使用auto时，如果内部宽度超过父级div时那么会出现滚动条；使用hidden时，如不能和position同时使用，如果超出尺寸会被隐藏。</code></pre><h2 id="11，JavaScript中定时器有哪些？它们的区别和用法是什么？"><a href="#11，JavaScript中定时器有哪些？它们的区别和用法是什么？" class="headerlink" title="11，JavaScript中定时器有哪些？它们的区别和用法是什么？"></a>11，JavaScript中定时器有哪些？它们的区别和用法是什么？</h2><pre class=" language-markdown"><code class="language-markdown">有两个；一个是setInterval，一个是setTimeout。1、setInterval:间歇性定时器。setInterval(func,time):每隔time时间(毫秒计)重复执行func函数。我们可以使用clearInterval来关闭这个定时器。2、setTimeout:延时定时器。setTimeout(func,time);隔time时间之后执行func。我们可以使用clearTimeout来关闭这个定时器。</code></pre><h2 id="12，列举最少5个jquery鼠标事件。"><a href="#12，列举最少5个jquery鼠标事件。" class="headerlink" title="12，列举最少5个jquery鼠标事件。"></a>12，列举最少5个<code>jquery鼠标事件</code>。</h2><pre class=" language-markdown"><code class="language-markdown">单击事件(click);双击事件(dbclick);移入事件(mouseover);移出事件(mouseout);鼠标按下事件(mousedown);鼠标抬起事件(mouseup);</code></pre><h2 id="13-简述requests模块的作用及基本使用？"><a href="#13-简述requests模块的作用及基本使用？" class="headerlink" title="13,简述requests模块的作用及基本使用？"></a>13,简述<code>requests模块</code>的作用及基本使用？</h2><pre class=" language-markdown"><code class="language-markdown">requests是用于网络请求,返回响应数据的一个模块，主要用于爬虫。主要是requests.get()和requests.post()两种请求方式，可以传递json参数；可以使用response.content获取二进制数据，也可以使用response.text获取文本数据，其中可以使用response.encoding指定编码类型；使用response.cookies返回对象中所有的cookie对象。</code></pre><h2 id="14，cookie和session的区别？"><a href="#14，cookie和session的区别？" class="headerlink" title="14，cookie和session的区别？"></a>14，<code>cookie</code>和<code>session</code>的区别？</h2><pre class=" language-markdown"><code class="language-markdown">cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息。它可以用来识别用户身份，记录历史。session是在无状态的http协议下，服务端记录用户状态时用于标识集体用户的机制。区别如下：1、session在服务端，cookie是在客户端；2、session用户无法查看和修改，cookie用户可以查看和修改；3、session和cookie的存储容量不同，cookie是4KB左右，而session大的多。4、session的实现依赖于 sessionID,而sessionID又存储在cookie上，所以：session是基于cookie实现的一种数据存储方式。</code></pre><h2 id="15-http和https的区别？"><a href="#15-http和https的区别？" class="headerlink" title="15,http和https的区别？"></a>15,http和https的区别？</h2><pre class=" language-markdown"><code class="language-markdown">http:超文本传输协议，是一个客户端和服务端请求和应答的标准(TCP)，用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。https：是基于安全套接字层的超文本传输协议(HTTPS = HTTP + SSL)。它主要作用分两种：1、建立一个信息安全通道，来保证数据传输的安全；2、确认网站的真实性。区别如下：1、https协议需要申请证书，这里需要一点费用；2、http是以无状态的连接方式来进行明文传输的超文本传输协议，而https是具有安全性的，可进行ssl加密传输，身份认证的网络协议；3、http的端口是80，https端口是443。</code></pre>]]></content>
      
      
      <categories>
          
          <category> python前端 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础面试题</title>
      <link href="/2018/11/23/ji-chu-mian-shi-ti/"/>
      <url>/2018/11/23/ji-chu-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="1，python中的关键字yield有什么作用？"><a href="#1，python中的关键字yield有什么作用？" class="headerlink" title="1，python中的关键字yield有什么作用？"></a>1，<code>python</code>中的关键字<code>yield</code>有什么作用？</h2><pre class=" language-markdown"><code class="language-markdown">yield会将该函数包装成生成器，之后可以对该生成器迭代。当一个函数运行到yield语句时，函数暂停，返回yield后面的表达式，当使用next(),send()方法时让原函数在暂停的地方继续执行。</code></pre><h2 id="2，这两个参数时什么意思-args-kwargs-我们为什么要使用他们？"><a href="#2，这两个参数时什么意思-args-kwargs-我们为什么要使用他们？" class="headerlink" title="2，这两个参数时什么意思:*args,**kwargs?我们为什么要使用他们？"></a>2，这两个参数时什么意思:<code>*args</code>,<code>**kwargs</code>?我们为什么要使用他们？</h2><pre class=" language-markdown"><code class="language-markdown"><span class="token code keyword">`*args`</span> 和 <span class="token code keyword">`**kwargs`</span>通常使用在函数定义里，<span class="token code keyword">`*args`</span>是不定长参数，允许函数传入不定量个数的非关键字参数，以元组形式接收；<span class="token code keyword">`**kwargs`</span>是不定长关键字参数，允许函数传入不定量个数的关键字参数，以字典形式接收。同时使用两者时，<span class="token code keyword">`*args`</span>参数必须在<span class="token code keyword">`**kwargs`</span>前面。</code></pre><h2 id="3-python主要的内置数据类型都有哪些？print-dir-39-a-39-的输出是什么？"><a href="#3-python主要的内置数据类型都有哪些？print-dir-39-a-39-的输出是什么？" class="headerlink" title="3,python主要的内置数据类型都有哪些？print(dir(&#39;a&#39;))的输出是什么？"></a>3,<code>python</code>主要的内置数据类型都有哪些？<code>print(dir(&#39;a&#39;))</code>的输出是什么？</h2><pre class=" language-markdown"><code class="language-markdown">字符串型元组列表集合字典数值型：整型，浮点型，布尔型，复数print(dir('a'))的输出是关键字参数['<span class="token bold"><span class="token punctuation">__</span>add<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>class<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>contains<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>delattr<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>dir<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>doc<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>eq<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>format<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>ge<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>getattribute<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>getitem<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>getnewargs<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>gt<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>hash<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>init<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>init_subclass<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>iter<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>le<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>len<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>lt<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>mod<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>mul<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>ne<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>new<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>reduce<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>reduce_ex<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>repr<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>rmod<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>rmul<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>setattr<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>sizeof<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>str<span class="token punctuation">__</span></span>', '<span class="token bold"><span class="token punctuation">__</span>subclasshook<span class="token punctuation">__</span></span>', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']</code></pre><h2 id="4，对比-args-和-kwargs-new-和-init-is和-的区别"><a href="#4，对比-args-和-kwargs-new-和-init-is和-的区别" class="headerlink" title="4，对比:*args 和**kwargs,__new__和__init__,is和==的区别"></a>4，对比:<code>*args</code> 和<code>**kwargs</code>,<code>__new__</code>和<code>__init__</code>,<code>is</code>和<code>==</code>的区别</h2><pre class=" language-markdown"><code class="language-markdown"><span class="token code keyword">`*args `</span>和 <span class="token code keyword">`**kwargs`</span>通常使用在函数定义里，<span class="token code keyword">`*args`</span>是不定长参数，允许函数传入不定量个数的非关键字参数，以元组形式接收；<span class="token code keyword">`**kwargs`</span>是不定长关键字参数，允许函数传入不定量个数的关键字参数，以字典形式接收。同时使用两者时，<span class="token code keyword">`*args`</span>参数必须在<span class="token code keyword">`**kwargs`</span>前面。<span class="token bold"><span class="token punctuation">__</span>new<span class="token punctuation">__</span></span>和<span class="token bold"><span class="token punctuation">__</span>init<span class="token punctuation">__</span></span>:<span class="token bold"><span class="token punctuation">__</span>init<span class="token punctuation">__</span></span>是当实例对象创建完成后被调用的，然后设置对象属性的初始值；<span class="token bold"><span class="token punctuation">__</span>new<span class="token punctuation">__</span></span>是在实例创建前被调用，它的任务就是创建实例然后返回该实例，是个静态方法。也就是说，<span class="token bold"><span class="token punctuation">__</span>new<span class="token punctuation">__</span></span>在<span class="token bold"><span class="token punctuation">__</span>init<span class="token punctuation">__</span></span>之前被调用，<span class="token bold"><span class="token punctuation">__</span>new<span class="token punctuation">__</span></span>的返回值(实例)将传递给<span class="token bold"><span class="token punctuation">__</span>init<span class="token punctuation">__</span></span>方法的第一个参数(self)然后<span class="token bold"><span class="token punctuation">__</span>init<span class="token punctuation">__</span></span>给这个实例设置参数。is和==:都是对对象进行比较判断，返回的都是布尔值。is也被叫做同一性运算符，判断的是内存id是否相同；==是python标准操作符中的比较操作符，用来比较判断两个对象的值是否相等。</code></pre><h2 id="5，装饰器-staticmethod和-classmethod-property的作用？"><a href="#5，装饰器-staticmethod和-classmethod-property的作用？" class="headerlink" title="5，装饰器@staticmethod和@classmethod,@property的作用？"></a>5，装饰器<code>@staticmethod</code>和<code>@classmethod</code>,<code>@property</code>的作用？</h2><pre class=" language-markdown"><code class="language-markdown">@staticmethod：类静态方法，与实例方法的区别是没有self参数，并且可以在类不进行实例化的情况下使用；@classmethod:类方法，与实例化方法的区别在于接收的第一个参数不是self(类实例的指针)，而是cls(当前类的具体类型)；@property:属性方法，将一个类方法转为类属性来使用，只读属性。</code></pre><h2 id="6，说说dict的item-方法和iteritems-方法的不同？"><a href="#6，说说dict的item-方法和iteritems-方法的不同？" class="headerlink" title="6，说说dict的item()方法和iteritems()方法的不同？"></a>6，说说dict的<code>item()</code>方法和<code>iteritems()</code>方法的不同？</h2><pre class=" language-markdown"><code class="language-markdown">item():可以将字典的所有键值对组成元组并且以列表的形式返回，因为dict是无序的，所以该返回的所有项也是无序的；iteritems():与items()作用大致相同，不过它的返回值是一个生成器。相对来说，item()需要花费更多的内存空间和时间，但访问某一项所花费的时间更少；iteritems()花费很少的空间，通过next()不断取下一个值。</code></pre><h2 id="7，python中的变量作用域-变量查找顺序-？"><a href="#7，python中的变量作用域-变量查找顺序-？" class="headerlink" title="7，python中的变量作用域(变量查找顺序)？"></a>7，python中的变量作用域(变量查找顺序)？</h2><pre class=" language-markdown"><code class="language-markdown">变量作用域是LEGB顺序。  1，什么是LEGB？  L:local,函数内部作用域(局部作用域)  E:enclosing,函数内部与内嵌函数之间  G:global,全局作用域  B:build-in,内置作用域  2，他们是做什么用的？  在学习python函数时，遇到定义域问题时，我们需要知道python是如何查找的。  3，查找顺序？  python在函数查找分为LEGB，与上面介绍的一样，先查找函数内部，然后是函数内部和嵌入函数之间(函数内部再次定义一个函数)，其次是查找全局变量，最后是内置作用域。</code></pre><h2 id="8，描述python中的进程，线程，协程？"><a href="#8，描述python中的进程，线程，协程？" class="headerlink" title="8，描述python中的进程，线程，协程？"></a>8，描述<code>python</code>中的进程，线程，协程？</h2><pre class=" language-markdown"><code class="language-markdown">进程:对于操作系统而已，一个任务就是一个进程，每个进程都有自己的堆栈段，代码段和数据段，以保存状态下接着执行，进程是操作系统资源分配的最小单位。线程:一个进程内部可以同时运行多个子任务，我们把进程的这些子任务叫做线程。进程和线程的区别:(1),进程是系统进行资源分配和调度的一个独立单位，线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位；(2),一个程序至少一个进程，一个进程至少一个线程；(3),线程的划分尺度小于进程(资源比进程少),使的多线程程序并发高；(4),进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大的提高程序的运行效率；(5),线程不能够独立执行，必须存在在进程中；(6),线程执行开销小，但不利于资源的管理和保护，进程相反。协程:协程又叫做微线程，一种用户态的轻量级线程，协程拥有自己的寄存器上下文和栈。优点: a,无需线程上下文切换的开销，协程避免了无意义的调度，由此可以提高性能。<span class="token code keyword">      b,无需原子操作锁定及同步开销。</span><span class="token code keyword">      c,方便切换控制流，简化编程模型。</span><span class="token code keyword">      d,高并发+高拓展性+低成本。</span>缺点: a,无法利用多核资源。<span class="token code keyword">      b,进行阻塞操作会阻塞掉整个程序。</span></code></pre><h2 id="9，简单比较一下python，java，javascript，如果您对后两者不熟悉，请和您熟悉的另一种语言比较。-不超过三句话"><a href="#9，简单比较一下python，java，javascript，如果您对后两者不熟悉，请和您熟悉的另一种语言比较。-不超过三句话" class="headerlink" title="9，简单比较一下python，java，javascript，如果您对后两者不熟悉，请和您熟悉的另一种语言比较。(不超过三句话)"></a>9，简单比较一下<code>python</code>，<code>java</code>，<code>javascript</code>，如果您对后两者不熟悉，请和您熟悉的另一种语言比较。(不超过三句话)</h2><pre class=" language-markdown"><code class="language-markdown">python 既有强类属性又有弱类属性；1、面向对象的编程，2、无需编译，提高开发效率，3、免费，开源，功能强大，4、简单易学，容易上手。js   弱类</code></pre><h2 id="10，说明os-sys模块的不同，并列举常用的模块方法？"><a href="#10，说明os-sys模块的不同，并列举常用的模块方法？" class="headerlink" title="10，说明os,sys模块的不同，并列举常用的模块方法？"></a>10，说明<code>os</code>,<code>sys</code>模块的不同，并列举常用的模块方法？</h2><pre class=" language-markdown"><code class="language-markdown">os:os模块提供了一种方便的使用操作系统函数的方法，该模块负责程序与操作系统的交互，提供访问操作系统底层的接口；(os.remove:删除文件；os.rename:重命名文件)sys:sys模块可供访问由解释器使用或维护的变量与解释器进行交互的函数，该模块负责程序与python解释器的交互，用于操作python的运行时的环境。(sys.version:获取python解释程序得版本信息；sys.platform:返回操作系统平台名称)(python常用模块:time模块、random模块、Json模块、re模块......)</code></pre><h2 id="11，你熟悉正则表达式吗？正则中search-和match-的区别？以及re-compile的作用？"><a href="#11，你熟悉正则表达式吗？正则中search-和match-的区别？以及re-compile的作用？" class="headerlink" title="11，你熟悉正则表达式吗？正则中search()和match()的区别？以及re.compile的作用？"></a>11，你熟悉正则表达式吗？正则中<code>search()</code>和<code>match()</code>的区别？以及<code>re.compile</code>的作用？</h2><pre class=" language-markdown"><code class="language-markdown">正则表达式描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种字串、将匹配的字串替换或者从某个串中提取出符合某个条件的字串等。两者都是正则表达式里的函数，search()匹配整个字符串，直到找到一个符合的匹配，如果找不到返回None；match()只匹配字符串的开始，如果一开始就不符合规则，返回None；两者都是匹配一次。补充：findall()匹配整个字符串找到所有符合表达式的字串，并以列表的形式返回，如果没有找到返回空列表[];finditer()于findall类似，不过返回的是一个迭代器。re.compile是将正则表达式编译成一个对象，加快匹配速度，并且可以重复使用。</code></pre><h2 id="12，python匹配HTML-tag的时候，-lt-gt-和-lt-gt-有什么区别？"><a href="#12，python匹配HTML-tag的时候，-lt-gt-和-lt-gt-有什么区别？" class="headerlink" title="12，python匹配HTML tag的时候，&lt;.*&gt;和&lt;.*?&gt;有什么区别？"></a>12，<code>python</code>匹配<code>HTML tag</code>的时候，<code>&lt;.*&gt;</code>和<code>&lt;.*?&gt;</code>有什么区别？</h2><pre class=" language-markdown"><code class="language-markdown">&lt;.<span class="token italic"><span class="token punctuation">*</span>>:贪婪模式；&lt;.<span class="token punctuation">*</span></span>?>:非贪婪模式。贪婪模式与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式是在整个表达式匹配成功的前提下尽可能多的匹配，而非贪婪模式是尽可能少的匹配。非贪婪模式只被部分NFA引擎支持。</code></pre><h2 id="13，python是如何进行内存管理的？"><a href="#13，python是如何进行内存管理的？" class="headerlink" title="13，python是如何进行内存管理的？"></a>13，<code>python</code>是如何进行内存管理的？</h2><p><a href="https://www.cnblogs.com/geaozhang/p/7111961.html" target="_blank" rel="noopener">点击查看</a></p><pre class=" language-markdown"><code class="language-markdown">python内部使用引用计数，来保持追踪内存中的对象，python内部记录了对象有多少个引用，即引用计数，当对象被创建时就创建一个引用计数，当对象不再需要时，这个对象的引用计数为0，它被垃圾回收。</code></pre><h2 id="14，什么是lambda函数，它有什么好处？"><a href="#14，什么是lambda函数，它有什么好处？" class="headerlink" title="14，什么是lambda函数，它有什么好处？"></a>14，什么是<code>lambda函数</code>，它有什么好处？</h2><pre class=" language-markdown"><code class="language-markdown">lambda函数是一个可以接收另意多个参数（包括可选参数）并返回单个表达式值的匿名函数。如：lambda x,y:x + y  获取x，y两个参数的和的lambda函数。好处：1、lambda函数比较轻便，即用即删除；2、一般用来给filter，map这样的函数式编程服务；3、作为回调函数，传递给某些应用，比如消息处理。缺点:更复杂的操作不适合，可读性不高。</code></pre><h2 id="15，分别说说cmp-map-filter的作用？"><a href="#15，分别说说cmp-map-filter的作用？" class="headerlink" title="15，分别说说cmp,map,filter的作用？"></a>15，分别说说<code>cmp</code>,<code>map</code>,<code>filter</code>的作用？</h2><pre class=" language-markdown"><code class="language-markdown">都是高阶函数。cmp:比较；cmp(a,b);a &lt; b，返回-1；a > b,返回1；a = b,返回0。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>python3中该函数被删除</span><span class="token punctuation">></span></span>map:映射；map(func,iterable);将func作用于iterable每个元素上，返回一个可迭代的对象。filter:过滤器；filter(func,iterable);将func依次作用于iterable的每个元素，如果返回值为true, 保留元素，否则从iterable里面删除,返回一个迭代器。</code></pre><h2 id="16-分别简述一下列表，元组，字典，集合的特点？"><a href="#16-分别简述一下列表，元组，字典，集合的特点？" class="headerlink" title="16,分别简述一下列表，元组，字典，集合的特点？"></a>16,分别简述一下列表，元组，字典，集合的特点？</h2><pre class=" language-markdown"><code class="language-markdown">上述都是python中常见的数据类型。列表：1、用list()函数或者[]创建，元素之间用逗号分隔；2、列表的元素不需要具有相同的类型；3、可以使用索引来访问元素(有序)；4、可以切片操作。元组：1、可以用tuple()函数或者()创建，元素之间用逗号分隔；2、元组的元素不需要具有相同的类型；3、可以使用索引来访问元素；4、可以切片操作；5、元素的值不可修改。字典：1、可以使用dict()函数或者{}创建，元素之间用逗号分隔，键和值之间用冒号隔开；2、元素由键（key）和值（value）组成 ；3、键必须是唯一，值可不唯一(无序)；4、通过键(key)访问元素。集合：1、通过set()函数或者{}创建，元素之间用逗号分隔；2、与字典相比少了键；3、不可索引不可切片，应为是无序的；4、不可以有重复元素，常常用作去重操作。</code></pre><h2 id="17-简述装饰器？"><a href="#17-简述装饰器？" class="headerlink" title="17,简述装饰器？"></a>17,简述装饰器？</h2><pre class=" language-markdown"><code class="language-markdown">装饰器本质上是一个python函数，所以可以传参数，并且它的返回值也是一个函数。装饰器的作用是可以让其他函数在不需要任何代码变动的前提下增加额外功能。功能：1、引入日志；2、统计函数执行时间；3、执行函数前预备处理；4、执行函数后清理功能；5、django中用到的权限验证；6、缓存中也用到了。</code></pre><h2 id="18，简述你对迭代器，生成器的理解；列表，字典，字符串是可迭代对象还是迭代器？"><a href="#18，简述你对迭代器，生成器的理解；列表，字典，字符串是可迭代对象还是迭代器？" class="headerlink" title="18，简述你对迭代器，生成器的理解；列表，字典，字符串是可迭代对象还是迭代器？"></a>18，简述你对迭代器，生成器的理解；列表，字典，字符串是可迭代对象还是迭代器？</h2><pre class=" language-markdown"><code class="language-markdown">迭代器：迭代器是指可以使用next()方法回调的对象(返回迭代的每一步，相当for循环，如果超出边界会抛出StopIteration异常)；也可以使用iter()方法将可迭代对象转换为迭代器。生成器：一个函数调用时返回一个迭代器或者函数中包含yield语法，那这个函数就是生成器，所以生成器是一种特殊的迭代器。在调用生成器运行的过程中，每次遇到yield时，函数会暂停并保存当前所有运行的运行信息，返回yield后面的表达式，并在下一次执行next()方法时从当前位置继续执行。可迭代对象：可以使用for...in...语句进行循环的对象，比如字符串、列表、元组、字典以及迭代器、生成器都是可迭代对象。所以，列表，字典，字符串都是可迭代对象。</code></pre><h2 id="19，一个编码为GBK的字符串S，要将其转成utf-8编码的字符串，应该如何操作？"><a href="#19，一个编码为GBK的字符串S，要将其转成utf-8编码的字符串，应该如何操作？" class="headerlink" title="19，一个编码为GBK的字符串S，要将其转成utf-8编码的字符串，应该如何操作？"></a>19，一个编码为GBK的字符串S，要将其转成utf-8编码的字符串，应该如何操作？</h2><pre class=" language-python"><code class="language-python">S<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span></code></pre><h2 id="20，有一朵28个花瓣的花朵，你和小明轮流摘，每人每次必须任意摘1到4个花瓣，能摘下最后一个花瓣的人获胜。如果你先摘并且想要获胜，你会选择第一次摘掉几个花瓣，原因是什么？"><a href="#20，有一朵28个花瓣的花朵，你和小明轮流摘，每人每次必须任意摘1到4个花瓣，能摘下最后一个花瓣的人获胜。如果你先摘并且想要获胜，你会选择第一次摘掉几个花瓣，原因是什么？" class="headerlink" title="20，有一朵28个花瓣的花朵，你和小明轮流摘，每人每次必须任意摘1到4个花瓣，能摘下最后一个花瓣的人获胜。如果你先摘并且想要获胜，你会选择第一次摘掉几个花瓣，原因是什么？"></a>20，有一朵28个花瓣的花朵，你和小明轮流摘，每人每次必须任意摘1到4个花瓣，能摘下最后一个花瓣的人获胜。如果你先摘并且想要获胜，你会选择第一次摘掉几个花瓣，原因是什么？</h2><pre class=" language-markdown"><code class="language-markdown">会先摘掉3个；先手拿3个，其他人后手无论拿1-4其中一个，我只要拿加起来等于5就行（乙1甲4，乙2甲3，乙3甲2，乙4甲1），每次两个人加起来刚好是5的倍数，我一定赢了。(3+5*5=28)</code></pre><h2 id="21-一行代码写出九九乘法表。"><a href="#21-一行代码写出九九乘法表。" class="headerlink" title="21,一行代码写出九九乘法表。"></a>21,一行代码写出九九乘法表。</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'\t'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token string">"%s*%s=%s"</span><span class="token operator">%</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token operator">*</span>j<span class="token punctuation">)</span><span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="22-什么是代码块？"><a href="#22-什么是代码块？" class="headerlink" title="22,什么是代码块？"></a>22,什么是代码块？</h2><pre class=" language-markdown"><code class="language-markdown">代码块是一组由代码构成的功能“单元”，以冒号作为开始，用缩进划分相同的作用域，它是一个整体。一个代码块可以单独运行。比如一个函数、一个类定义、一个模块等。</code></pre><h2 id="23，变量是什么？"><a href="#23，变量是什么？" class="headerlink" title="23，变量是什么？"></a>23，变量是什么？</h2><pre class=" language-markdown"><code class="language-markdown">变量是可以改变的量，实际上是内存中一块存储空间。变量由以下几个命名规范：1、尽量不要使用中文；2、可以使用数字，字母，下划线；3、数字不能开头；4、下划线不能开头；5、严格区分大小写；6、变量要具有描述性；7、不能使用关键字作为变量。</code></pre><h2 id="24，全局变量和局部变量的区别，如何在一个函数里给一个全局变量赋值？"><a href="#24，全局变量和局部变量的区别，如何在一个函数里给一个全局变量赋值？" class="headerlink" title="24，全局变量和局部变量的区别，如何在一个函数里给一个全局变量赋值？"></a>24，全局变量和局部变量的区别，如何在一个函数里给一个全局变量赋值？</h2><pre class=" language-markdown"><code class="language-markdown">全局变量与局部变量两个的本质区别就是作用域的不同。全局变量在整个py文件中申明，全局范围内都可以访问；局部变量是在某个函数中申明，只在该函数调用时可以访问。使用global关键字可以给全局变量赋值。num1 = 1def fun():  <span class="token code keyword">    global num1  </span><span class="token code keyword">    num1=2  </span><span class="token code keyword">    print("函数内修改后num1=",num1)  # 2</span>num1=1  print("初始num1=",num1)  # 1fun()  print("运行完函数后num1=",num1) # 2</code></pre><h2 id="25，什么是面向对象？"><a href="#25，什么是面向对象？" class="headerlink" title="25，什么是面向对象？"></a>25，什么是面向对象？</h2><pre class=" language-markdown"><code class="language-markdown">面向对象是一种程序设计思想。它把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。在python中所有数据类型都可以视为对象，当然也可以自定义对象，自定义对象的数据类型就是面向对象中的类的概念。所有面向对象的设计思想是抽象出类，根据类创建实例。因此类是创建实例的模板，而实例则是一个个具体的对象，各个实例拥有的数据都是互相对立，互不影响。其中数据封装，继承，多态是面向对象的三大特点。1、封装：所谓封装就是把类中的属性和方法私有化。这样可以将变化隔离和便于我们使用。2、继承：继承就是创建一种新类的方法，新类可以从之前存在的类继承，因此新类称之为子类，被继承的类称为父类。所以新类可以将父类的所有功能之间拿过来使用而不需要重新写，当然也可以新增自己特有的方法，也可以把父类不适合的方法覆盖重写。3、多态：多态就是一个类有多个子类。比如一个动物类可以有狗类，猫类。所有不同的子类调用父类相同的方法时会产生不同的执行结果。</code></pre><h2 id="26，python2和python3的区别？"><a href="#26，python2和python3的区别？" class="headerlink" title="26，python2和python3的区别？"></a>26，<code>python2</code>和<code>python3</code>的区别？</h2><pre class=" language-markdown"><code class="language-markdown">1.Python3 使用 print 必须要以小括号包裹打印内容，比如 print('hi')2.python2 range(1,10)返回列表，python3中返回迭代器，节约内存3.python2中使用ascii 编码，python中使用utf-8编码4.python2中unicode表示字符串序列，str表示字节序列，python3中str表示字符串序列，byte表示字节序列5.python2中为正常显示中文，引入coding声明，python3中不需要6.python2中是raw_input()函数，python3中是input()函数</code></pre><h2 id="27-单引号，双引号，三引号的区别？"><a href="#27-单引号，双引号，三引号的区别？" class="headerlink" title="27,单引号，双引号，三引号的区别？"></a>27,<code>单引号</code>，<code>双引号</code>，<code>三引号</code>的区别？</h2><pre class=" language-markdown"><code class="language-markdown">单引号('...')、双引号("...")、和三引号('''...''')或("""...""")包围，三引号包含字符串可由多行组成，一般可表示大段的叙述性字符串。也可以加注释。在使用上没有多大区别，但双引号和三引号中可以包含单引号和双引号而不需要转义。</code></pre><h2 id="28，字符串格式化：-s和-format的区别？"><a href="#28，字符串格式化：-s和-format的区别？" class="headerlink" title="28，字符串格式化：%s和.format的区别？"></a>28，字符串格式化：<code>%s</code>和<code>.format</code>的区别？</h2><pre class=" language-markdown"><code class="language-markdown">.format函数灵活强大，可以接受的参数不限个数，并且位置可以不按顺序，而且有较为强大的格式限定符(比如：填充，对齐，精度等)</code></pre><h2 id="29-简述with方法打开处理文件时帮我们做了什么？"><a href="#29-简述with方法打开处理文件时帮我们做了什么？" class="headerlink" title="29,简述with方法打开处理文件时帮我们做了什么？"></a>29,简述<code>with方法</code>打开处理文件时帮我们做了什么？</h2><pre class=" language-markdown"><code class="language-markdown">当with体完成时，会自动实现finally中的f.close()函数，关闭文件，而不需要考虑文件的异常判断。</code></pre><h2 id="30，简单解释下python的GIL锁-全局解释锁-。"><a href="#30，简单解释下python的GIL锁-全局解释锁-。" class="headerlink" title="30，简单解释下python的GIL锁(全局解释锁)。"></a>30，简单解释下<code>python</code>的<code>GIL锁</code>(全局解释锁)。</h2><pre class=" language-markdown"><code class="language-markdown">GIL锁简单来说就是一个互斥体，这样的机制只允许一个线程来控制python解释器。这就意味着在任何一个时间点只有一个线程处于执行状态。所以在IO操作等可能引起阻塞前会暂时释放GIL,但在执行完毕后必须重新获取GIL。为了解决它带来的麻烦可以使用以下几个方案：1、更换解释器；2、将线程的代码换成其他语言执行；3、使用多进程完成多任务处理。</code></pre><h2 id="31，utf-8和unicode的区别是什么？"><a href="#31，utf-8和unicode的区别是什么？" class="headerlink" title="31，utf-8和unicode的区别是什么？"></a>31，<code>utf-8</code>和<code>unicode</code>的区别是什么？</h2><pre class=" language-markdown"><code class="language-markdown">unicode是字符集，是为每一个字符分配一个唯一ID(学名为码位/码点)；utf-8是编码规则，是一套以8位为一个编码单位的可变长编码。会将一个字符集编码为1到4个字节。</code></pre><h2 id="32，1-2-2014-的结果末尾有多少个0？请写出解题思路或者计算过程。"><a href="#32，1-2-2014-的结果末尾有多少个0？请写出解题思路或者计算过程。" class="headerlink" title="32，1  2 . . .  2014 的结果末尾有多少个0？请写出解题思路或者计算过程。"></a>32，1 <em> 2 . . . </em> 2014 的结果末尾有多少个0？请写出解题思路或者计算过程。</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> reducea <span class="token operator">=</span> str<span class="token punctuation">(</span>reduce<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span>y<span class="token punctuation">:</span>x<span class="token operator">*</span>y<span class="token punctuation">,</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2015</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> i <span class="token operator">!=</span> <span class="token string">'0'</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    count <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 501</span></code></pre><h2 id="33-写一段代码，逐行读入一个中文档案-编码为utf-8-，输出在荧幕上并合并-去掉换行-输出另外一个档案。"><a href="#33-写一段代码，逐行读入一个中文档案-编码为utf-8-，输出在荧幕上并合并-去掉换行-输出另外一个档案。" class="headerlink" title="33,写一段代码，逐行读入一个中文档案(编码为utf-8)，输出在荧幕上并合并(去掉换行)输出另外一个档案。"></a>33,写一段代码，逐行读入一个中文档案(编码为utf-8)，输出在荧幕上并合并(去掉换行)输出另外一个档案。</h2><pre class=" language-python"><code class="language-python">f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'文件名.txt'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 以行为单位读取全文</span>f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> ret<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'新的文件名.txt'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>i<span class="token punctuation">)</span></code></pre><h2 id="34-python中如何动态获取和设置对象属性？"><a href="#34-python中如何动态获取和设置对象属性？" class="headerlink" title="34,python中如何动态获取和设置对象属性？"></a>34,<code>python</code>中如何动态获取和设置对象属性？</h2><pre class=" language-markdown"><code class="language-markdown">1,dir([obj]):调用这方法将返回包含obj大多数属性名的列表(会有一些特殊的属性不包含在内)，obj的默认值时当前模块对象；2,hasattr(obj,attr):调用这个方法时检查obj是否有一个名为attr的属性，返回布尔值；3,getattr(obj,attr):调用这个方法将返回obj中名为attr属性的值，例如：如果attr为'name',则返回obj.name的值。4,setattr(obj,attr,'小明'):调用这个方法将给obj的名attr的属性赋值为“小明”；例如：attr为'name'，则obj.name = '小明'。</code></pre><h2 id="35，请使用python内置函数处理如下问题："><a href="#35，请使用python内置函数处理如下问题：" class="headerlink" title="35，请使用python内置函数处理如下问题："></a>35，请使用python内置函数处理如下问题：</h2><pre><code>1.请判断一个字符串是否以er结尾；2.请将“#teacher#”两侧的“#”去除；3.请使用map函数将[1,2,3,4]处理成[1,0,1,0];4.请使用filter函数将[1,2,3,4]处理成[2,4];5.请使用reduce函数计算100的阶乘(1*2*3*..*99*100)</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 1</span>val<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">'er'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 2</span>str <span class="token operator">=</span> <span class="token string">'#teacher#'</span>str<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'#'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 3</span>a <span class="token operator">=</span> map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span> <span class="token number">0</span> <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 4</span>b <span class="token operator">=</span> filter<span class="token punctuation">(</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span> x <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 5</span><span class="token keyword">from</span> functools <span class="token keyword">import</span> reducec <span class="token operator">=</span> reduce<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span>y <span class="token punctuation">:</span>x<span class="token operator">*</span>y<span class="token punctuation">,</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>int<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="36，深拷贝和浅拷贝的区别？"><a href="#36，深拷贝和浅拷贝的区别？" class="headerlink" title="36，深拷贝和浅拷贝的区别？"></a>36，深拷贝和浅拷贝的区别？</h2><ul><li>浅拷贝(copy):拷贝父对象，不会拷贝对象内部的子对象。</li><li>深拷贝(deepcopy): copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> copya <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#原始对象</span>b <span class="token operator">=</span> a                       <span class="token comment" spellcheck="true">#赋值，传对象的引用</span>c <span class="token operator">=</span> copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>a<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#对象拷贝，浅拷贝</span>d <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>a<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#对象拷贝，深拷贝</span>a<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true">#修改对象a</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#修改对象a中的['a', 'b']数组对象</span><span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'a = '</span><span class="token punctuation">,</span> a <span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'b = '</span><span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'c = '</span><span class="token punctuation">,</span> c <span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">'d = '</span><span class="token punctuation">,</span> d <span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>d <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 浅拷贝时，列表外层不变，内层跟着改变；深拷贝时，内外层都不变，拷贝的对象和原列表无关</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>web面试题</title>
      <link href="/2018/11/21/web-hou-tai-kuang-jia-mian-shi-ti/"/>
      <url>/2018/11/21/web-hou-tai-kuang-jia-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="1，Django、Flask、Tornado的对比"><a href="#1，Django、Flask、Tornado的对比" class="headerlink" title="1，Django、Flask、Tornado的对比"></a>1，<code>Django</code>、<code>Flask</code>、<code>Tornado</code>的对比</h2><pre class=" language-markdown"><code class="language-markdown">1,Django走的是大而全的方向，开发效率高。它的MVT框架，自带ORM，admin后台管理，自带的splite数据库和开发测试用的服务器，给开发之提高了超高的开发效率。2，Flask是轻量级的框架，自由，灵活，可拓展性强，核心基于werkzeug WSGI工具和jinja2模板引擎3，Tornado走的是少而精的方向，性能优越。它最出名的是异步非阻塞的设计方式。它的两大核心模块：<span class="token code keyword">    a:iostraem:对非阻塞式的socket进行简单的封装</span><span class="token code keyword">    b:ioloop:对I/O多路复用的封装，它实现了一个单例</span></code></pre><h2 id="2，简述MVC和MVT。"><a href="#2，简述MVC和MVT。" class="headerlink" title="2，简述MVC和MVT。"></a>2，简述<code>MVC</code>和<code>MVT</code>。</h2><pre class=" language-markdown"><code class="language-markdown">MVT和MVC都是框架式。MVC的设计核心是为了让不同的代码块之间降低耦合，增强代码的可拓展性和可移植性，实现向后兼容。M是模型，model，负责业务对象与数据库的映射(ORM:对象-关系映射)，可以让我们不写SQL语句操作数据库；V是视图，view，负责与用户的交互，生成页面展示html内容；C是控制器，controller，用于接收请求，处理业务逻辑，与model，view交互，返回结果。而django框架中的MVT借用了MVC的思想。M是模型，model，与MVC中的M功能一样，负责和数据库交互；V是视图，view，与MVC中的C功能一样，先定义好对象所需要的功能函数，再负责接收请求，处理业务逻辑，然后返回结果；T是模板，template，与MVC中的V功能一样，负责生成页面，展示给用户看。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>此外django中还有urls分发器，将不同的url分发给不同的view处理</span><span class="token punctuation">></span></span></code></pre><h2 id="3，django中如何读取和保存session，整个session运行机制是什么？"><a href="#3，django中如何读取和保存session，整个session运行机制是什么？" class="headerlink" title="3，django中如何读取和保存session，整个session运行机制是什么？"></a>3，<code>django</code>中如何读取和保存<code>session</code>，整个<code>session</code>运行机制是什么？</h2><pre class=" language-markdown"><code class="language-markdown">在django中使用 request.session['order<span class="token italic"><span class="token punctuation">_</span>id'] = order<span class="token punctuation">_</span></span>id 来保存session，使用 session.get来读取session。(可以使用del request.session['order<span class="token italic"><span class="token punctuation">_</span>id']删除，如果key不存在会报错；request.session.clear()清除所有会话，但是数据保留；request.session.flush()删除当前的会话数据)session将信息以加密的方式存储在服务器端，然后将一个 session<span class="token punctuation">_</span></span>id 交给浏览器中的cookie保存，当我们需要数据时，就将cookie中的session<span class="token italic"><span class="token punctuation">_</span>id发送给服务器，这样服务器端根据这个session<span class="token punctuation">_</span></span>id相对安全的在数据库中查询用户的信息。</code></pre><h2 id="4，简述django对http请求的执行流程。"><a href="#4，简述django对http请求的执行流程。" class="headerlink" title="4，简述django对http请求的执行流程。"></a>4，简述django对http请求的执行流程。</h2><p><img src="https://upload-images.jianshu.io/upload_images/260723-033f4db0fc89e522.png?imageMogr2/auto-orient/" alt="点击查看详情"></p><pre class=" language-markdown"><code class="language-markdown">分为以下几个步骤：1、将http请求打包一个HttpRequest对象，交给Request中间件处理；2、如果处理的结果时一个response，则将response传给response中间件，返回http响应；  如果不是response，则将request请求传给view中间件；3、如果传给view中间件抛出异常则经过Exception中间件，之间返回response，交给rseponse中间件做收尾工作；如果不抛异常则判断是否返回response；4、如果返回的是response，则交给response中间件做收尾工作；如果不是response，则调用view视图函数，返回rsponse。再交给response中间件做收尾工作。</code></pre><h2 id="5，cookie和session的区别？"><a href="#5，cookie和session的区别？" class="headerlink" title="5，cookie和session的区别？"></a>5，<code>cookie</code>和<code>session</code>的区别？</h2><pre class=" language-markdown"><code class="language-markdown">cookie是在客户端保存用户信息的一种机制。session是服务端用来识别用户的一种机制。它们有以下几个区别：1、cookie是保存在客户端中，而session是保存在服务端中；2、cookie保存的数据大小不超过4K，session要大得多；3、cookie当中的数据信息可以查看和修改，因此不太安全，而session不可查看和修改；4、session的实现依赖于session<span class="token italic"><span class="token punctuation">_</span>id,而session<span class="token punctuation">_</span></span>id又是保存在cookie中，索引session是依赖于cookie而存在的一种数据存储形式。</code></pre><h2 id="6，请简要说明django框架中视图的作用？"><a href="#6，请简要说明django框架中视图的作用？" class="headerlink" title="6，请简要说明django框架中视图的作用？"></a>6，请简要说明django框架中<code>视图</code>的作用？</h2><pre class=" language-markdown"><code class="language-markdown">它的作用就是先定义好各类对象所需功能的函数，然后接收请求，处理业务逻辑，返回结果。其中每一个视图函数都对应着一个url。</code></pre><h2 id="7，Django中查询QuerySet时什么情况下用Q"><a href="#7，Django中查询QuerySet时什么情况下用Q" class="headerlink" title="7，Django中查询QuerySet时什么情况下用Q?"></a>7，Django中查询<code>QuerySet</code>时什么情况下用Q?</h2><pre class=" language-markdown"><code class="language-markdown">QuerySet是django的查询集。我们一般使用filter()、exclude()来进行按单一条件查询。当我们需要进行复杂的查询时，比如两个条件是and或者or,这时上面两个方法就不适合了。所以我们可以使用Q()将这些条件组成一个Q对象，其中多个Q对象可以使用‘或、且、非’进行组合。这样我们就可以将Q对象当作参数传递给filter()、get()、exclude()进行复杂查询。</code></pre><h2 id="8，django的优缺点？"><a href="#8，django的优缺点？" class="headerlink" title="8，django的优缺点？"></a>8，django的优缺点？</h2><pre class=" language-markdown"><code class="language-markdown">优点：1、功能完善，自带大量的常用工具和框架(比如：分页，权限认证)；2、自带后台管理系统；3、debug信息详细，查找错误代码方便；4、modle层自带ORM组件，无需写sql语句就可以对数据库进行操作；缺点：1、开发小应用时不如Flask；2、框架中的组件之间耦合度过高，不易拆分；</code></pre><h2 id="9，flask的优缺点？"><a href="#9，flask的优缺点？" class="headerlink" title="9，flask的优缺点？"></a>9，flask的优缺点？</h2><pre class=" language-markdown"><code class="language-markdown">优点：1、flask只提供了核心功能，简单优雅；2、自由，灵活，可拓展性强；3、适合开发web服务的API;缺点：1、第三方库引用过于频繁</code></pre><h2 id="10，django请求的生命周期？"><a href="#10，django请求的生命周期？" class="headerlink" title="10，django请求的生命周期？"></a>10，django请求的生命周期？</h2><pre class=" language-markdown"><code class="language-markdown">Django的请求生命周期是指当用户输入url后到返回页面的这个时间段，django后台所发生的事。它分为以下几个步骤：1、输入url后，浏览器生成请求头和请求体发送给服务端，请求头和请求体会包含浏览器的动作，  这个动作通常为get或post，这个会体现在url中；2、url经过django中的wsgi(web服务网关接口)，再经过中间件验证，最后到路由映射表，  一个一个进行匹配路由，一旦匹配成功就执行相应的视图函数，后面的路由就不匹配；3、视图函数根据客户端的请求查询相应的数据返回给django，django将数据转换为字符串返回给客户端；4、客户端接收返回的数据经过模板渲染后显示给用户看。</code></pre><h2 id="11，Django中想验证表单提交是否格式正确需要用到Form中的哪个函数？"><a href="#11，Django中想验证表单提交是否格式正确需要用到Form中的哪个函数？" class="headerlink" title="11，Django中想验证表单提交是否格式正确需要用到Form中的哪个函数？"></a>11，Django中想验证表单提交是否格式正确需要用到Form中的哪个函数？</h2><pre class=" language-python"><code class="language-python">is_valid<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="12，Flask-WTF是什么，有什么特点？"><a href="#12，Flask-WTF是什么，有什么特点？" class="headerlink" title="12，Flask-WTF是什么，有什么特点？"></a>12，<code>Flask-WTF</code>是什么，有什么特点？</h2><pre class=" language-markdown"><code class="language-markdown">Flask-WTF是一个用于表单处理，校验并且提供CSRF验证功能的集成WTForms。它能够使表单不受CSRF(跨站请求伪造)的攻击。</code></pre><h2 id="13，Django-作为一个-Web-开发框架，它包括哪些基本组成部分："><a href="#13，Django-作为一个-Web-开发框架，它包括哪些基本组成部分：" class="headerlink" title="13，Django 作为一个 Web 开发框架，它包括哪些基本组成部分："></a>13，Django 作为一个 Web 开发框架，它包括哪些基本组成部分：</h2><pre class=" language-markdown"><code class="language-markdown">一个django项目由以下几个组成：url.py、view.py、model.py、admin.py、settings.py、templatesdjango是一种基于MVT的框架，所有基本由三个部分组成：M:model,模型，负责和数据库交互，其ORM(对象-关系映射)组件可以让我们不书写SQL语句便可以操作数据库；V:view,视图，负责处理业务逻辑，接收http请求，匹配url，调用视图函数，返回结果；T，template,模板，将返回的结果渲染成页面展示。</code></pre><h2 id="14，Django路由系统中name的作用？"><a href="#14，Django路由系统中name的作用？" class="headerlink" title="14，Django路由系统中name的作用？"></a>14，Django路由系统中<code>name</code>的作用？</h2><pre class=" language-markdown"><code class="language-markdown">可以用于反向解析路由，相当于给url取别名，当url改变时，我们依然可以根据这个别名找到该条url。</code></pre><h2 id="15，什么是中间件并简述其作用？"><a href="#15，什么是中间件并简述其作用？" class="headerlink" title="15，什么是中间件并简述其作用？"></a>15，什么是中间件并简述其作用？</h2><pre class=" language-markdown"><code class="language-markdown">Django的中间件是一个轻量级，底层的插件系统，就是一个类。可以介入Django请求和响应处理过程，修改Django的输入和输出。在Django中每个中间件按照顺序执行不同的功能。中间件的工作过程如下：1、一个请求按照从上往下的顺序进入中间件，调用process<span class="token italic"><span class="token punctuation">_</span>request方法；2、然后被中间件的process<span class="token punctuation">_</span></span>view方法处理，调用view.py文件；3、在调用视图函数时如果出错，则从下往上调用process<span class="token italic"><span class="token punctuation">_</span>exception方法，把错误信息通过  process<span class="token punctuation">_</span></span>response方法返回数据给客户端；4、如果调用视图函数不报错，则通过process_response方法返回数据返回给客户端。</code></pre><h2 id="16，列举Django中的内置组件。"><a href="#16，列举Django中的内置组件。" class="headerlink" title="16，列举Django中的内置组件。"></a>16，列举Django中的内置组件。</h2><pre class=" language-markdown"><code class="language-markdown">1、model是负责操作数据库的组件；2、Admin是对model中对应的数据表进行增删改查提供的组件；3、form组件：生成html代码、数据有效性校验、校验信息返回并展示4、ModelForm组件可以用于数据库操作，也可以用于用户请求；</code></pre><h2 id="17，什么是WSGI-uwsgi-uWSGI。"><a href="#17，什么是WSGI-uwsgi-uWSGI。" class="headerlink" title="17，什么是WSGI,uwsgi,uWSGI。"></a>17，什么是<code>WSGI</code>,<code>uwsgi</code>,<code>uWSGI</code>。</h2><pre class=" language-markdown"><code class="language-markdown">WSGI(Web Server Gateway Interface)是web服务器网关接口,是一种描述web服务器如何与web程序通信的规范；uWSGI是一个全功能的HTTP服务器，实现了WSGI协议、uwsgi协议、HTTP协议等。比如把http协议转化成WSGI协议,让python可以之间使用。uwsgi是uWSGI服务器的独占通信协议，用于定于传输信息类型。</code></pre><h2 id="18-简述一下FBV和CBV。"><a href="#18-简述一下FBV和CBV。" class="headerlink" title="18,简述一下FBV和CBV。"></a>18,简述一下<code>FBV</code>和<code>CBV</code>。</h2><pre class=" language-markdown"><code class="language-markdown">FBV(function base views) : 基于函数的视图；CBV(class base views) : 基于类的视图；当用户发送url请求，Django会一次遍历路由映射表中的所有记录，一旦有一条记录匹配成功就执行相对于的函数，并且不再继续匹配记录，这就是FBV的执行流程。当服务端使用CBV模式时，用户发送给服务端的请求包含url和method，这两个信息都是字符串类型，然后服务端会通过路由映射表匹配成功后会自动去找dispatch(调度)方法，接下来Django通过dispatch反射的方式找到类相对应的方法并执行，执行完毕返回数据给dispatch方法，由dispatch方法将数据返回给客户端。使用CBV的优点如下：1、提高了代码的复用性，可以使用面向对象技术，比如多继承；2、可以用不同的函数对不同的HTTP方法处理，提高代码的可读性。</code></pre><h2 id="19，django中实现csrf的机制。"><a href="#19，django中实现csrf的机制。" class="headerlink" title="19，django中实现csrf的机制。"></a>19，django中实现csrf的机制。</h2><pre class=" language-markdown"><code class="language-markdown">csrf是跨站请求伪造，可以盗用你的身份对浏览器发送恶意请求并得到响应。它的机制分为3步：1、django第一次响应某个客户端的请求时，后端随机生成一个token值，后端把这个token值存在session状态中，同时把token值放到cookie里交给浏览器；2、浏览器第二次请求时把cookie中的token值加入请求头信息中，一起传给后端；Cookies:{csrftoken:xxxxxxx}3、服务器接收请求，将session中的token值与cookie中的token值验证。如果一致返回响应，不一致返回403 Forbidden。</code></pre><h2 id="20，基于django中使用ajax发送post请求时，都可以使用哪种方法携带csrf-token。"><a href="#20，基于django中使用ajax发送post请求时，都可以使用哪种方法携带csrf-token。" class="headerlink" title="20，基于django中使用ajax发送post请求时，都可以使用哪种方法携带csrf token。"></a>20，基于django中使用ajax发送post请求时，都可以使用哪种方法携带csrf token。</h2><pre class=" language-markdown"><code class="language-markdown">1、后端将csrftoken值发送给前端，使用post请求时再带上这个值：  data:{csrfmiddlewaretoken:'{{ csrf_token }}'}2、获取form表单中隐藏标签的csrftoken值，加入到请求数据发送给服务端：  data:{csrfmiddlewaretoken:$('[name="csrfmiddlewaretoken"]').val()}3、在cookie中保存csrftoken值，发送请求时将值放在请求头：  headers:{"X-CSRFtoken":$.cookie("csrftoken")}</code></pre>]]></content>
      
      
      <categories>
          
          <category> django </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web</title>
      <link href="/2018/11/21/web-kai-fa-chu-shi-md/"/>
      <url>/2018/11/21/web-kai-fa-chu-shi-md/</url>
      
        <content type="html"><![CDATA[<h1 id="一，Web应用结构及工作原理"><a href="#一，Web应用结构及工作原理" class="headerlink" title="一，Web应用结构及工作原理"></a>一，Web应用结构及工作原理</h1><p><img src="/2018/11/21/web-kai-fa-chu-shi-md/webjg.png" alt="web"></p><h1 id="二，Web框架"><a href="#二，Web框架" class="headerlink" title="二，Web框架"></a>二，Web框架</h1><h2 id="1，什么是框架？"><a href="#1，什么是框架？" class="headerlink" title="1，什么是框架？"></a>1，什么是框架？</h2><p>软件框架就是为实现或完成某种软件开发时,提供了一些基础的软件产品,</p><p>框架的功能类似于<strong>基础设施</strong>,提供并实现<strong>最为基础的软件架构和体系</strong></p><p>通常情况下我们依据框架来实现更为复杂的业务程序开发</p><p>框架就是程序的<strong>骨架</strong></p><h2 id="2，框架的优缺点"><a href="#2，框架的优缺点" class="headerlink" title="2，框架的优缺点"></a>2，框架的优缺点</h2><pre><code>可重用成熟，稳健可扩展性良好选对框架很重要</code></pre><h2 id="3，python中常见的框架"><a href="#3，python中常见的框架" class="headerlink" title="3，python中常见的框架"></a>3，python中常见的框架</h2><p>大包大揽 Django 被官方称之为完美主义者的Web框架。</p><p>力求精简 web.py和Tornado</p><p>新生代微框架 Flask和Bottle</p><h2 id="4，web框架中的一些概念"><a href="#4，web框架中的一些概念" class="headerlink" title="4，web框架中的一些概念"></a>4，web框架中的一些概念</h2><p><strong>MVC</strong></p><ul><li>大部分开发语言中都有MVC框架</li><li>MVC框架的核心思想是：解耦</li><li>降低各功能模块之间的耦合性，方便变更，更容易重构代码，最大程度上实现代码的重用</li><li>m表示model，主要用于对数据库层的封装</li><li>v表示view，用于向用户展示结果</li><li>c表示controller，是核心，用于处理请求、获取数据、返回结果 </li></ul><p><strong>MVT</strong></p><ul><li>Django是一款python的web开发框架</li><li>与MVC有所不同，属于MVT框架</li><li>m表示model，负责与数据库交互</li><li>v表示view，是核心，负责接收请求、获取数据、返回结果</li><li>t表示template，负责呈现内容到浏览器</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django</title>
      <link href="/2018/11/20/django-chu-shi/"/>
      <url>/2018/11/20/django-chu-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Django简介"><a href="#Django简介" class="headerlink" title="Django简介"></a>Django简介</h1><h2 id="1，认识Django"><a href="#1，认识Django" class="headerlink" title="1，认识Django"></a>1，认识Django</h2><ul><li>Django是一个高级的Python Web框架，它鼓励快速开发和清洁，务实的设计。</li><li>由经验丰富的开发人员构建，它负责Web开发的许多麻烦，因此您可以专注于编写应用程序，而无需重新创建轮子。</li><li>它是免费的和开源的。</li><li>被官方称之为完美主义者的Web框架。</li><li>Django可以更快地构建更好的Web应用程序并减少代码。</li><li>官方网址：<a href="https://www.djangoproject.com/" target="_blank" rel="noopener">https://www.djangoproject.com/</a></li><li>中文文档:<br><a href="http://python.usyiyi.cn/" target="_blank" rel="noopener">http://python.usyiyi.cn/</a></li></ul><h2 id="2，Django框架的特点："><a href="#2，Django框架的特点：" class="headerlink" title="2，Django框架的特点："></a>2，Django框架的特点：</h2><ul><li>快速开发：Django的宗旨在于帮助开发人员快速从概念到完成应用程序。</li><li>安全可靠：Django认真对待安全性，帮助开发人员避免许多常见的安全错误。</li><li>超可伸缩性: Web上的一些最繁忙的网站利用了Django快速灵活扩展的能力。</li></ul><h2 id="3，Django安装"><a href="#3，Django安装" class="headerlink" title="3，Django安装"></a>3，Django安装</h2><pre><code>在线安装Djangopip install Django检测当前是否安装Django及版本python3 -m django --version</code></pre><h2 id="4-Django的框架的搭建"><a href="#4-Django的框架的搭建" class="headerlink" title="4,Django的框架的搭建"></a>4,Django的框架的搭建</h2><pre><code>django-admin startproject mysite  mysite 是项目的目录名，可以自定义</code></pre><h2 id="4，启动项目"><a href="#4，启动项目" class="headerlink" title="4，启动项目"></a>4，启动项目</h2><pre><code>sudo python3 manage.py runserver</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Web开发 </tag>
            
            <tag> Linux </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sql语句</title>
      <link href="/2018/11/13/sql-yu-ju/"/>
      <url>/2018/11/13/sql-yu-ju/</url>
      
        <content type="html"><![CDATA[<p>这里收集了一些<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a>和<a href="https://leetcode-cn.com/" target="_blank" rel="noopener">领扣</a>常用的sql语句。。。</p><hr>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
            <tag> python </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
